#### 本节主要讲多线程引起的线程安全性问题，以及线程之间的通信问题

####1.目前来看，并发安全性的问题基本就是对多个线程之间的共享变量进行控制，
####  使共享变量在最少影响性能的范围内进行串行化的计算
####2.由此，就有了锁这个概念。java中控制线程串行化运行的锁有很多
####  本节主要讲了synchronized的用法和原理
####3.synchronized的用法
####  分为锁类实例、锁class实例、锁指定对象,不同的锁的方式代表锁的粒度不同
####4.synchronized的原理
####  首先，synchronized是通过jvm指令monitorenter和monitorexit来实现加锁和解锁
####  其次，synchronized是存储在获得锁的对象的对象头里的，也就是存储在对象的markword里面，
####  不同的锁存储的字节编码不一样，以用来区分
####5.为什么任何对象都可以实现锁
####  (1). 首先，Java 中的每个对象都派生自 Object 类，而每个Java Object 在 JVM 内部都有
####  一个 native 的 C++对象oop/oopDesc 进行对应。
####  (2). 线程在获取锁的时候，实际上就是获得一个监视器对象(monitor) ,monitor 可以认为是
####  一个同步对象，所有的 Java 对象是天生携带 monitor。多个线程访问同步代码块时，相当于去
####  争抢对象监视器 修改对象中的锁标识
####6.synchronized的升级
####  jvm对synchronized做了优化，不是一开始就是重量级锁，所谓重量锁，是指在处理线程并发竞争时
####  其他线程会阻塞住，而非重量级的锁不会用阻塞来处理竞争。
synchronized的升级一般是由无锁->偏向锁—>轻量级锁->重量级锁的过程
7.偏向锁
偏向锁认为大多数情况下只会有一个线程来获取它，它偏向于上一个获取锁的线程，所以叫偏向锁。
由于偏向锁并不阻塞，所以会出现多个线程同时去往锁对象头里写自己的线程ID，所以偏向锁使用cas来完成线程
ID的写入。同时cas也是乐观锁的核心原理。
当一个线程获取偏向锁后，锁对象的对象头里会存储这个线程的ID，当下一次有线程进入到锁的同步块时，
则不需要再次加锁和解锁，直接查看锁里面存的线程ID是不是当前线程。如果是则直接运行，如果不是，则偏向锁
升级为轻量级锁。
8.轻量级锁
轻量级锁面对竞争的处理是通过自旋。也就是没有获取到锁的线程并不会挂起阻塞，而是会做一定次数的空循环。
轻量级锁认为线程自旋等待一会的时间开销要比线程挂起切换的开销要小。当然，在一定次数的自旋后，如果还是
无法成功获取锁。则会发生锁膨胀，变成重量级锁。
9.重量级锁
重量级锁就是常说的阻塞锁，对于多个线程竞争的情况，除了获取锁的线程，其他线程全部挂起。当一个线程因阻塞
被挂起时,他会产生两次额外的上下文切换,以及必要的操作系统操作和缓存操作(上下文切换会导致高速缓存中的内容丢失),
这些都是阻碍系统高速运行的原因。