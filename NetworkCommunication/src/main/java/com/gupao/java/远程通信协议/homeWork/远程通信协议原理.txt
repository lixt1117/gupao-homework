1.tcp/ip的三次握手和四次挥手是什么概念，以及状态变化过程？
    三次握手和四次挥手是指在tcp/ip协议中，请求端和响应端建立连接和关闭连接的交互过程。

    三次握手状态过程：
        （1）客户端发送SYN标志1和SEQ序列号X（SYN-Synchronize Sequence
            Numbers，同步序列号），此时客户端变为SYN_SENT状态。
        （2）服务端收到后，要返回确认信息，发送应答信息ACK=X+1，和自己的SEQY。
            此时服务端状态由listen变成SYN_RCVD（猜测服务器打开后就是监听listen状态）
        （3）客户端收到应答后自身变成ESTABLISHED（连接建立）状态，同时也发送一个应答信息
            ACK=Y+1，服务端收到后自身变成ESTABLISHED状态。
    四次挥手状态过程：
        （1）由于TCP的全双工特性，客户端和服务端都可以主动发起关闭。这里假设客户端先请求关闭，
            客户端发送关闭请求，包含关闭标志FIN=1，SEQ=X+2，ACK=Y+1，此时客户端由ESTABLISHED
            变为FIN-WAIT1状态
        （2）服务端收到后，自身变为CLOSE—WAIT状态，并返回一个应答ACK=X+3，客户端收到后，
            自身即变成FIN-WAIT2状态。
        （3）当服务端处理好所有事情可以关闭时，再发送一个应答给客户端：FIN=1，SEQ=Y+1,自身
            变为LAST—ACK状态
        （4）客户端收到后自身变为TIME-WAIT状态，并发送最后一个应答给服务端：ACK=Y+2。TIME-WAIT
            状态会等待两个最大段生命周期（TCP规定2分钟，Linux设置成了30s）自己关闭变为CLOSED状态。
            而服务端收到应答后会关闭变为CLOSED

2.建立连接需要3次，为什么断开连接需要4次？
    建立连接的过程其实是双方确认彼此的SYN的过程，这个过程不需要等待。一来一去一共三次。
    断开连接4次是因为一端收到请求后一般不会立即关闭，需要等任务处理完才能关，所以只能先返回一个
    应答给请求端，等自己完事了再发一个信息给对方，然后对方确认了自己再关闭，所以需要四次

3.三次握手有哪些不安全性？
    容易引起SYN Flood攻击

4.TCP和UDP的区别？TCP是通过什么方式来保证可靠性的
    1、基于连接与无连接；

    2、对系统资源的要求（TCP较多，UDP少）；

    3、UDP程序结构较简单；

    4、流模式与数据报模式 ；

    5、TCP保证数据正确性，UDP可能丢包；

    6、TCP保证数据顺序，UDP不保证。

5.tcp四层网络模型和osi七层网络模型分别是什么？以及每一层的作用
    osi七层网络模型：
    应用层：网络服务与最终用户的一个接口。
        协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP
    表示层：数据的表示、安全、压缩。（在因特网五层模型里面已经合并到了应用层）
        格式有，JPEG、ASCll、EBCDIC、加密格式等
    会话层：建立、管理、终止会话。（在因特网五层模型里面已经合并到了应用层）
        对应主机进程，指本地主机与远程主机正在进行的会话
    传输层：定义传输数据的协议端口号，以及流控和差错校验。
        协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层
    网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。
        协议有：ICMP IGMP IP（IPV4 IPV6）
    数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。（由底层网络定义协议）
          将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。
    物理层：建立、维护、断开物理连接。（由底层网络定义协议）

    tcp四层网络模型
    应用层：负责处理众多业务逻辑，如文件传输、网络管理
    传输层：对应OSI七层参考模型的传输层，它提供两种端对端的通信服务，TCP和UDP。
    网络层：负责数据的包装、寻址和路由
    数据链路层：定义像地址解析协议（Address Result Protocol，ARP）这样的协议，
        提供TCP/IP协议的数据结构和实际物理硬件之间接口。

6.什么是滑动窗口协议？它的实现原理是什么？
    滑动窗口是针对于发送端和接收端的一种流量控制策略。在某些情况下，接收端处理数据的能力
    比发送端发送数据的能力低很多（或者发送端的数据太多），会造成接收端的队列塞满。因此有了滑动窗口，
    接收端告诉发送端一次最多可以发送多少数据。

    TCP 头部中有一个 Window size, 这个就是接收方告诉发送方，我现在的容量是多少，
    你发送的数据流大小必须小于我的这个容量。

    窗口更新过程：
    1.接收方的处理数据能力 > 缓冲区的增长速度，这个时候接收方缓冲区的空间就会增大，因此 Window size 也会增大。
    2.发送方接受到接收方发来的ack，窗口的左边界就会向右移动，同时也会根据 Window size 调整窗口的右边界。

    特殊情况：当头部的 Window size 是 0 的时候，发送方就不能继续发送数据了。那当接收方处理
    掉一部分数据之后，发送方怎么知道接收方有新的空间？当 Window size 为 0 的时候，
    发送方会发送一个包 ZWP(Zero Window Probe) 给接收方，接收方收到包以后，
    会以 ack 的形式返回目前的 Window size。如果发了三个 ZWP，返回的都是 0，
     那么发送方会选择异常关闭连接(RST)。异常关闭连接(RST)不用等缓冲区的数据都发送完毕，
     接收方也不需要发送 ack。

    总的看下来，滑动窗口是一个在端对端的流量控制策略。 一开始两端会协商一个初始的窗口大小，
    然后根据窗口大小来确定发送哪些数据；数据传输过程中，接收端不断更新 Window size，
    发送方根据这个返回的值更新自己的窗口大小，达到一种流量控制的目的。

7.服务器上TIME_WAIT状态的连接过多，怎么解决？
    这种情况是因为客户端服务器上TIME_WAIT状态的连接过多，一般出现在高并发短连接的场景。

    修改服务端，只能缓解问题，不能解决根本问题。
    #增加对外连接的端口范围，缺省情况下很小：32768到61000，改为1024到65000。
    net.ipv4.ip_local_port_range = 1024 65000
    #加大SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。
    net.ipv4.tcp_max_syn_backlog = 8192

    修改客户端服务器，打开系统的TIMEWAIT重用和快速回收：
    #允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
    net.ipv4.tcp_tw_reuse = 1
    #Time-Wait socket的快速回收，默认为0，表示关闭
    net.ipv4.tcp_tw_recycle = 1
    #修改系统默认的 time-out时间（tcp_fin_timeout）
    net.ipv4.tcp_fin_timeout

8.什么是NIO、BIO、AIO？他们的区别？
    BIO，同步阻塞IO。分为连接阻塞和数据流阻塞（write，read）。
    NIO，同步非阻塞IO，客户端通过轮询检查服务端缓冲区数据是否准备就绪，
        服务端未准备就绪会返回Ewoudblock错误。服务端准备就绪后，会将数据
        从系统内核copy到用户空间，然后将数据返回给客户端。
    AIO，异步非阻塞IO。通过异步回调实现。

9.了解过多路复用吗？它是一个什么实现原理？
    客服端和服务端通信时，客服端注册一个监听，服务器通过监听socket fd（文件描述符）状态，
    发现有可用的fd时，通知客户端数据准备就绪。客户端接收到通知后，发起读写操作，服务端将数据返回给客户端。
10.epool和select的区别是什么？
    epoll和select都是同步非阻塞的具体实现。
    -IO性能
    select通过轮询方式检查fd状态，随着fd的增加，性能会下降。
    epoll基于事件回调驱动，活跃的fd会发起回调，在活跃fd较少时，性能会很好。
    但是在所有socket fd活跃时，性能会下降。

    连接数
    select的连接数有限，32位机器默认是1024个，64位机器默认是2048个。
    epoll的连接数也有上限，但是很大，1G内存的机器10万左右的连接数。
    消息快递方式
    select：服务器通知用户就绪后，客户端发起读写操作时，系统内核将消息copy到用户空间。
    epoll：系统内核和用户空间共享一块内存。通知用户数据就绪时，数据已经位于了用户空间。