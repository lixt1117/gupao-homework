ConcurrentHashMap源码阅读笔记

put:
==============================================================================
put方法实际是调用putVal方法，该方法中：
1.先判断key或value是不是null，如果是则抛空指针（这里与hashmap不同，hashmap是允许key和value为null的）
2.接下来调用spread方法获取key的哈希值，该方法其实就是将key的hashcode的高16位和低16位进行按位异或操作再
	按位与上HASH_BITS这个常量，这是一个除了符号位其他都是1的数据。
	那么：
		（1）为什么要高低位异或
			这是为了让数据更加分布平均，因为有一些key比如浮点数，它们的hashcode低位都是0，这样在后面进行定位
			时，得到的key的真正哈希值（hash&（数组长度-1））都是0，而让高位也参与运算可以很好避免这个情况
		（2）为什么要比hashmap多一步&HASH_BITS的操作
			因为这样做了之后可以保持得到的哈希值是正数，因为哈希值0和负数在CHM代表其他含义
3.接下来进入一个自旋：
	（1）首先判断哈希数组tab是否为空，如果是调用initTable方法初始化。该方法内部是一个while循环，
		循环的条件就是tab为空
	（2）接下来会判断sizeCtl的值，这里先说一下这个值的作用。sizeCtl有很多含义，如果在CHM初始化的时候没有
		指定大小，那么一开始的默认值是0，如果指定了大小，它的值就是最靠近指定值的2的幂次方。当有一个线程进行初
		始化后，它会变成-1。当tab正在扩容时，它会变成-N，N的值是正在扩容的线程数+1。当初始化或扩容结束后，
		它会变成当前容量的0.75，也就是下一次扩容的阈值。
		（PS：这里扩容部分说的不准确，扩容的时候sizeCtl低16位是记录扩容线程数+1，高16位是记录的当前的扩容戳）
		所以，在while循环中，首先会判断该值是否小于0，如果是，代表有其他线程正在扩容。那么直接Thread.yield()
		让出CPU资源。同时也结束了本次循环，当扩容结束后循环会结束。
	（3）如果sizeCtl>=0，则通过cas将sizeCtl更新成-1，更新成功就开始初始化数组tab。创建一个大小为指定值或者默认16的
		Node<K,V>数组，并且把sizeCtl设置为当前容量的0.75
	（4）如果tab不为空，那么通过tabAt(tab, i = (n - 1) & hash)方法去获取定位到的数组位置，
		这里有两点：
			I.为什么要用n-1与上哈希值作为散列算法？
			  因为hashmap的散列算法就是那哈希值和数组大小进行取余，而在计算机中，按位取模比取余效率高（关于这两个区别主要是对
			  负数的算法不同，参见我的印象笔记）。所以才会用哈希值按位与上数组大小减一，这也是为什么hashmap的大小必须是2的幂次方。
			  因为只有这样，按位与操作才能起到取模的效果。
			II.tabAt怎么保证在并发时的总能取到最新的数据？
				虽然tab数组是volatile修饰的，但是我们知道数组内部是不受volatile影响的，tabAt是用了Unsafe类的getObjectVolatile方法来保证该操作具有和volatile一样的语义
	（5）获取到数组位置后，如果该位置是null也就是还没有数据，则直接cas更新，成功的话结束自旋
	（6）如果不为空，先判断该位置的Node节点f的哈希值是否为-1，之前说过CHM的哈希值负数是有特殊含义的就在这里，-1表示这个桶
		正在扩容中，那么调用helpTransfer方法帮助扩容，关于该方法后面再说（附1）
	（7）如果f的哈希值不为-1，就得查找这个桶上的链表或者红黑树去看这个key是不是已经存在了，红黑树的部分本次先不看，链表的遍历
		很简单，首先用synchronized锁住当前的桶节点f，接着遍历链表，如果是同一个key，默认是会替换value的。如果遍历完了也
		没有，则在链表最后加入当前的数据。然后结束自旋
	（8）在自旋的最后，都会判断一个当前链表的元素数量是否大于等于8，如果是则调用treeifyBin方法转换成红黑树，这里暂时也不展开
4.在自旋结束后，会调用addCount方法，进行更新CHM的元素大小，addCount方法有两个参数long x, int check，x代表这次
	添加的元素个数，默认是1，check代表所在桶的链表长度，当check<0时不需要检查，<=1时只需要检查有没有竞争，>1需要
	检查是否需要扩容。
	在该方法中：
	（1）首先进行元素总个数的更新，先判断counterCells数组是否为null，在CHM中，元素总个数是通过一个long类型的BASECOUNT和
		counterCells数组分段存储的。
		如果counterCells为null，则通过cas更新BASECOUNT，如果更新成功，则进入下一环节检查扩容
		如果counterCells不为null或者cas更新失败了，则进行下一步判断，判断条件依次如下：
			I.counterCells为null
			II.counterCells大小为0
			III.通过多线程ThreadLocalRandom得到的随机数&counterCells的长度减一（这里类似于哈希一下，只不过只需要写不需要再
				查找了，所以直接用了随机数没用hashcode）	定位到的counterCells[x]是null
			IV.通过cas更新counterCells[x]的值失败了
		通过上述的条件，如果某一项符合则调用fullAddCount方法，并发的更新元素总数。该方法后面再说（附2）
	（2）更新完元素总数后，接着判断是否需要扩容，判断元素总个数是否大于等于阈值且数组tab长度未超过上限的情况下，
		需要扩容。
	（3）首先调用resizeStamp方法得到当前长度的扩容戳，该方法是返回数组长度n的最高位非0位前面的0的个数按位或上（2的15次方），
	因为数组长度始终是2的幂次方，所以不同的长度得出的扩容戳不一样的。
	（4）接着判断sizeCtl的值，如果小于0，表示正在扩容（因为这里sizeCtl不可能为-1，毕竟初始化肯定已完成了），
		sizeCtl小于0就表示有其他线程正在扩容了，这里会进行判断一系列判断：
			I.如果sizeCtl的高16为不等于当前的扩容戳，代表当前这轮扩容已经结束
			II.如果sizeCtl等于扩容戳+1，表示扩容已经结束（这里看了半天不能理解，以后再说吧）
			III.判断当前扩容的线程数是否达到最大值
			IV.nextTable等于null，nextTable是扩容的新的数组的暂时存放地，为null表示扩容已结束
			V.transferIndex <= 0,transferIndex是扩容的数组索引，是从后往前开始递减的，变成0说明可分配的扩容区间已经分配完了

			当上述条件符合时，直接结束while循环,结束put方法了
			如果都不符合，表示可以参与扩容，调用transfer方法（牛逼的设计，多线程协助扩容）
		如果sizeCtl>=0(这里只可能大于0)，表示当前线程是第一个扩容的，则通过cas将sizeCtl赋值(rs << 16) + 2，rs是扩容戳。
		为什么要左移16位是因为sizeCtl的高位存储扩容戳，低位存储线程数+1。之所以+2不是+1是因为-1代表的是正在初始化，所以只能+2了。
		（PS：这里也是为什么我不理解sizeCtl等于扩容戳+1就表示扩容已经结束，明明sizeCtl的高位是扩容戳，这里不右移再比较我是没看明白）
		更新完sizeCtl后也是调用transfer方法进行扩容
	（5）下面来看transfer方法
		a.首先transfer的扩容是每个线程负责一个桶区间然后在这个区间内倒序扩容，所以一开始先要计算区间大小，
		  区间大小stride = (NCPU > 1) ? (n >>> 3) / NCPU : n，也就是用CPU核心数除以数组长度，如果求得
		  的stride小于16，则区间大小设为16。
		  (之所以除以CPU核心数是为了让每个线程尽量分配平均，在不考虑超线程技术时，计算机同时运行的最大线程数=CPU核心数)
		b.接着判断新的数组nextTab是否初始化，没有初始化就去初始化
		c.接下来会进入一个比较复杂的自旋中,因为这个自旋里面包含了大量的if-else和其他的循环：
			I.首先进入一个while循环，这里有两个变量i和bound，i代表进行扩容的下标，一般初始值是数组尾部下标，然后递减。
			  bound是区间的左边界值，比方说一个长度64的数组，扩容的时候第一个线程的区间就是[48,63],那么bound=48，i=63
			  while循环实际就是替当前线程分配所负责的区间，以下情况会退出循环：
			  · 已经分配好区间且当前线程还没完成它的任务
			  · 扩容已经结束
			  · 可分配的区间已经分配完了
			II.while循环之后会进入一个超长的if-else判断。。逻辑基本如下：
			  · 首先判断扩容下标i，如果i < 0 || i >= n || i + n >= nextn，表示当前线程已经结束了自己的扩容区间，
			    需要进行收尾工作。其中,i<0好理解，表示线程已经完成当前任务且没有可分配的桶了，至于另外两个条件
			    目前看不懂，以后再说
			  · 如果当前线程已经可以结束扩容，先判断是否全部扩容完毕，如果是，把tab更新为新的tab，更新sizeCtl位新的阈值
			  	如果只是本线程完成了任务，则直接返回
			III.下面来看具体的扩容和数据迁移逻辑，
			  · 如果当前桶里面是空的，直接放入刚刚初始化的 ForwardingNode ”空节点“，该节点哈希值为-1
			  · 如果当前桶的节点哈希值为-1，表示其他线程正在处理这个桶，直接跳过
			  · 如果上述两种都不是，那么要开始迁移旧数组的数据到新数组去。
			  	首先对桶节点加锁synchronized，然后把这个链表中的元素分为两类，A 类是 hash 值的第 X 位为 0，B 类是 hash 值 的第 x 位为不等于 0	。最终要达到的目的是，A 类的链表保持位置不动，B 类的链表为 原位置+扩容增加 的长度。
			  	之所以这么做是和hashmap定位下标的算法有关，这样区分后，可以避免重新计算哈希，提升性能

基本到这里put方法差不多了

至于get方法，比较简单，是个非阻塞的，因为tabat方法的可见性语义，get方法不需要加锁也能获取到最新数据，唯一注意的是，当定位到的下标正在扩容时（hash=-1），会通过find方法去新的tab里先找到值



		























