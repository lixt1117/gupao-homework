####1.为什么要使用多线程？
#####使用多线程的目的就是在于最大限度的利用CPU资源。
对于单核的机器来说，如果处理的任务不存在IO之类的
阻塞情况，使用多线程应该不会有什么优势，因为线程之间的切换会造成额外的开销。但是如果处理中发生了
阻塞，比如在写入磁盘时IO阻塞，线程在等待磁盘处理完成才能执行下一步。这个时候就可以使用多线程，在
一个线程等待的时候，另一个线程去处理其他的逻辑。
而对于多核的机器来说，使用多线程可以实现并行处理任务，充分利用多核的优势

####2.java中如何创建线程
#####实现Runnable接口
#####继承或者直接使用Thread类
#####使用线程池
#####使用Future和Callable

####3.线程的生命周期
#####线程一共有 6 种状态(NEW、RUNNABLE、BLOCKED、 WAITING、TIME_WAITING、TERMINATED) 
#####NEW:初始状态，线程被构建，但是还没有调用 start 方法 
#####RUNNABLED:运行状态，JAVA 线程把操作系统中的就绪 和运行两种状态统一称为“运行中” 
#####BLOCKED:阻塞状态，表示线程进入等待状态,也就是线程 因为某种原因放弃了 CPU 使用权，阻塞也分为几种情况
 #####➢等待阻塞:运行的线程执行 wait 方法，jvm 会把当前 线程放入到等待队列
 #####➢ 同步阻塞:运行的线程在获取对象的同步锁时，若该同 步锁被其他线程锁占用了，那么 jvm 会把当前的线程 放入到锁池中
➢ 其他阻塞:运行的线程执行 Thread.sleep 或者 t.join 方 法，或者发出了 I/O 请求时，JVM
  会把当前线程设置 为阻塞状态，当 sleep 结束、join 线程终止、io 处理完 毕则线程恢复
#####WAITING: 没有超时时间的等待，只有在线程被notify/All或者LockSupport.unpark方法唤醒
#####TIME_WAITING:超时等待状态，超时以后自动返回
#####TERMINATED:终止状态，表示当前线程执行完毕
####4.线程的启动方法分析
代码上直接调用Thread的start方法即可启动一个线程，对此方法观看jvm源码后发现start方法最终是调用
os::createThread方法，也就是当前系统的创建线程方法
####5.线程的终止方法分析
Thread的stop方法虽然可以终止线程，但是java本身已经弃用。原因嘛，据老师说，这个方法类似于linux的
kill -9一样，暴力结束线程，会出问题。
所以一般终止线程都是通过线程的中断来实现，也就是interrupt方法。
使用interrupt方法终止线程分两种情况：
#####（一）线程本身有阻塞行为，这种情况使用interrupt时，线程会抛出中断异常，java会强制要求处理异常，如果开发者认为中断时应该停止线程，则可以在catch块里进行自定义处理
#####（二）线程本身不会阻塞，这种情况使用interrupt也不会有中断异常抛出，一般这种情况下如果需要停止线程，可以监听线程的interrupt标志，因为interrupt方法实际上就是改变了中断标志的值
####6.关于interrupt方法的底层思考
（一）之所以阻塞操作会引发中断异常而非阻断不会，因为对于非阻断异常来说，你想停止它完全可以设置一个
变量来操控。而对于阻塞操作来说，比如线程调用数据的保存，线程正在等待数据库的返回结果。这时候线程是
无法自己停止的，只能靠抛出异常来停止
 